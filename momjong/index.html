<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1e4d2e">
<link rel="manifest" href='data:application/manifest+json,{"name":"Mahjong","short_name":"Mahjong","display":"standalone","background_color":"#1e4d2e","theme_color":"#1e4d2e"}'>
<title>Classic Mahjong</title>
<style>
    :root {
        --board-bg: #1e4d2e;
        --tile-bg: #fffae6;
        --tile-border: #d4cbb3;
        --tile-shadow: #8c836c;
        --highlight: #ffd700;
        --hint-color: #32cd32;
    }

    body {
        margin: 0;
        padding-top: env(safe-area-inset-top);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        padding-bottom: env(safe-area-inset-bottom);
        background-color: var(--board-bg);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #fff;
        display: flex;
        flex-direction: row; 
        height: 100vh;
        box-sizing: border-box;
        overflow: hidden; 
    }

    #board-container {
        position: relative;
        flex-grow: 1;
        height: 100%;
        overflow: hidden; 
    }

    #board-scale-wrapper {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 1250px; 
        height: 750px;
    }

    aside.sidebar {
        background-color: rgba(0, 0, 0, 0.6);
        width: 120px; 
        height: 100%;
        padding: 20px 15px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        box-shadow: -4px 0 10px rgba(0,0,0,0.3);
        z-index: 100;
        gap: 25px;
    }

    .controls {
        display: flex;
        flex-direction: column;
        gap: 15px;
        width: 100%;
    }

    .game-number {
        font-size: 1.1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        font-weight: bold;
        width: 100%;
        text-align: center;
    }

    input[type="number"] {
        font-size: 1.2rem;
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
        border-radius: 6px;
        border: none;
        text-align: center;
        background: #fff;
    }

    button {
        font-size: 2.2rem; 
        padding: 15px 10px; 
        width: 100%;
        border: none;
        border-radius: 8px;
        background-color: #e0e0e0;
        color: #333;
        cursor: pointer;
        transition: transform 0.1s;
        box-shadow: 0 4px #999;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    button:active {
        box-shadow: 0 0 #999;
        transform: translateY(4px);
    }
    
    button.primary {
        background-color: #4CAF50;
        color: white;
        box-shadow: 0 4px #2E7D32;
    }

    .tile {
        position: absolute;
        width: 85px; 
        height: 115px; 
        background-color: var(--tile-bg);
        border: 2px solid var(--tile-border);
        border-radius: 8px;
        box-shadow: 4px 4px 0px var(--tile-shadow), 5px 5px 8px rgba(0,0,0,0.6);
        cursor: pointer;
        user-select: none;
        transition: transform 0.1s, filter 0.3s, box-shadow 0.1s;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .tile.blocked {
        filter: brightness(0.4);
        cursor: not-allowed;
    }

    .tile.selected {
        transform: translateY(-8px);
        box-shadow: 0 0 20px 8px var(--highlight);
        border-color: var(--highlight);
        z-index: 999 !important;
    }

    .tile.hint {
        animation: pulse 1s infinite alternate;
        box-shadow: 0 0 20px 8px var(--hint-color);
        border-color: var(--hint-color);
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        100% { transform: scale(1.05); }
    }

    .tile svg {
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .modal {
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.85);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background-color: #fff;
        color: #333;
        padding: 30px;
        border-radius: 12px;
        max-width: 600px;
        width: 90%;
        font-size: 1.2rem;
        line-height: 1.5;
        position: relative;
    }

    .close-btn {
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 2.5rem;
        cursor: pointer;
        color: #888;
    }

    #win-message {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 5rem;
        font-weight: bold;
        color: #ffd700;
        text-shadow: 3px 3px 15px rgba(0,0,0,0.9);
        z-index: 500;
        text-align: center;
        width: 100%;
    }

    #win-message button {
        margin: 20px auto;
        font-size: 2rem;
        padding: 15px 30px;
        width: auto; 
    }

    #portrait-warning {
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: var(--board-bg);
        z-index: 2000;
        color: white;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 2rem;
        padding: 20px;
    }

    @media (orientation: portrait) {
        #portrait-warning {
            display: flex;
        }
    }

    /* Vertical compression for phones in landscape */
    @media (max-height: 450px) {
        aside.sidebar {
            padding: 10px 10px;
            gap: 10px;
            width: 100px;
        }
        .controls {
            gap: 8px;
        }
        .game-number {
            gap: 4px;
            font-size: 1rem;
        }
        input[type="number"] {
            padding: 4px;
            font-size: 1rem;
        }
        button {
            padding: 8px 5px;
            font-size: 1.6rem;
        }
    }

</style>
</head>
<body>

<div id="portrait-warning">
    <div style="font-size: 4rem; margin-bottom: 20px;">üîÑ</div>
    Please rotate your phone to landscape mode to play.
</div>

<div id="board-container">
    <div id="board-scale-wrapper">
        <div id="win-message">YOU WIN!<br><button class="primary" onclick="initGame()">üîÑ Play Again</button></div>
    </div>
</div>

<aside class="sidebar">
    <div class="game-number">
        <div>Game #</div>
        <input type="number" id="game-seed" max="99999" min="1">
        <div id="difficulty-score"> </div>
    </div>
    <div class="controls">
        <button class="primary" onclick="initGame(true)" title="New Game">üÜï</button>
        <button onclick="showHint()" title="Hint">üí°</button>
        <button onclick="document.getElementById('help-modal').style.display='flex'" title="Help">‚ùì</button>
        <button id="fullscreen-btn" onclick="toggleFullScreen()" title="Full Screen">‚õ∂</button>
    </div>
</aside>

<div id="help-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="document.getElementById('help-modal').style.display='none'">&times;</span>
        <h2 style="margin-top:0; color:#1e4d2e;">How to Play</h2>
        <p><strong>Goal:</strong> Remove all tiles by finding matching pairs.</p>
        <ul>
            <li>You can only select a tile if it is <strong>"Free"</strong>.</li>
            <li>A tile is Free if there is <strong>no tile covering it</strong>, AND it is open on <strong>either its left or right side</strong>.</li>
            <li>Dark tiles are blocked. Bright tiles are ready to play!</li>
            <li><strong>Exceptions:</strong> Any üå∏ Flower matches any other Flower. Any ‚ùÑÔ∏è Season matches any other Season.</li>
        </ul>
    </div>
</div>

<div id="hint-modal" class="modal">
    <div class="modal-content" style="text-align: center;">
        <span class="close-btn" onclick="document.getElementById('hint-modal').style.display='none'">&times;</span>
        <h2 style="margin-top:0; color:#1e4d2e;">No Matches Found</h2>
        <p>There are no visible matches available right now.</p>
        <p>You might be stuck! Try starting a <strong>New Game</strong>.</p>
        <button class="primary" onclick="document.getElementById('hint-modal').style.display='none'; initGame(true)" style="margin: 20px auto 0; width: auto;">Start New Game</button>
    </div>
</div>

<script>
    function generateDeck() {
        const deck = [];
        for(let i=1; i<=9; i++) {
            for(let j=0; j<4; j++) {
                deck.push({type: 'dot', val: i});
                deck.push({type: 'bam', val: i});
                deck.push({type: 'char', val: i});
            }
        }
        ['N', 'S', 'E', 'W'].forEach(w => { for(let j=0; j<4; j++) deck.push({type: 'wind', val: w}); });
        ['Red', 'Green', 'White'].forEach(d => { for(let j=0; j<4; j++) deck.push({type: 'dragon', val: d}); });
        ['F1','F2','F3','F4'].forEach(f => deck.push({type: 'flower', val: f}));
        ['S1','S2','S3','S4'].forEach(s => deck.push({type: 'season', val: s}));
        return deck;
    }

    function generateLayout() {
        const layout = [];
        let id = 0;
        for(let x=0; x<14; x++) for(let y=0; y<6; y++) layout.push({id: id++, x, y, z: 0});
        for(let x=2; x<=11; x++) for(let y=1; y<=4; y++) layout.push({id: id++, x, y, z: 1});
        for(let x=4; x<=9; x++) for(let y=2; y<=3; y++) layout.push({id: id++, x, y, z: 2});
        for(let x=5; x<=8; x++) for(let y=2; y<=3; y++) layout.push({id: id++, x, y, z: 3});
        return layout;
    }

    let seed = 12345;
    function random() {
        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }

    function shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex !== 0) {
            randomIndex = Math.floor(random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }

    function isMatch(t1, t2) {
        if (t1.id !== undefined && t2.id !== undefined && t1.id === t2.id) return false;
        if (t1.type === 'flower' && t2.type === 'flower') return true;
        if (t1.type === 'season' && t2.type === 'season') return true;
        return t1.type === t2.type && t1.val === t2.val;
    }

    function generateWinnableBoard() {
        let maxAttempts = 100;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            let deck = shuffle(generateDeck()); 
            let layout = generateLayout();
            let remainingSlots = [...layout];
            let assignedTiles = [];
            let stuck = false;

            while (remainingSlots.length > 0) {
                let freeSlots = remainingSlots.filter(s => {
                    let above = remainingSlots.some(r => r.z === s.z + 1 && r.x === s.x && r.y === s.y);
                    if (above) return false;
                    let blockedLeft = remainingSlots.some(r => r.z === s.z && r.y === s.y && r.x === s.x - 1);
                    let blockedRight = remainingSlots.some(r => r.z === s.z && r.y === s.y && r.x === s.x + 1);
                    return !(blockedLeft && blockedRight);
                });

                if (freeSlots.length < 2) {
                    stuck = true; 
                    break;
                }

                shuffle(freeSlots);
                let slot1 = freeSlots[0];
                let slot2 = freeSlots[1];

                let tile1 = deck.pop();
                let matchIdx = deck.findIndex(t => isMatch(tile1, t));
                let tile2 = deck.splice(matchIdx, 1)[0];

                assignedTiles.push({ ...slot1, type: tile1.type, val: tile1.val });
                assignedTiles.push({ ...slot2, type: tile2.type, val: tile2.val });

                remainingSlots = remainingSlots.filter(s => s.id !== slot1.id && s.id !== slot2.id);
            }

            if (!stuck) return assignedTiles;
        }
        return []; 
    }

    let activeTiles = [];
    let selectedTileId = null;

    function renderSVG(type, val) {
        let svg = `<svg viewBox="0 0 60 80" xmlns="http://www.w3.org/2000/svg">`;
        let label = "";
        if (['dot', 'bam', 'char'].includes(type)) label = val;
        else if (type === 'wind') label = val;
        else if (type === 'dragon') label = val.charAt(0);
        else label = type === 'flower' ? 'Fl' : 'Se';
        
        svg += `<text x="4" y="16" font-size="18" font-family="sans-serif" font-weight="bold" fill="#222">${label}</text>`;

        if (type === 'dot') {
            const positions = [
                [], [[30, 45]], [[30, 30], [30, 60]], [[20, 25], [30, 45], [40, 65]], 
                [[20, 25], [40, 25], [20, 65], [40, 65]], [[20, 25], [40, 25], [30, 45], [20, 65], [40, 65]], 
                [[20, 25], [40, 25], [20, 45], [40, 45], [20, 65], [40, 65]], 
                [[20, 20], [40, 20], [30, 35], [20, 50], [40, 50], [20, 65], [40, 65]], 
                [[20, 20], [40, 20], [20, 35], [40, 35], [20, 50], [40, 50], [20, 65], [40, 65]], 
                [[20, 20], [40, 20], [20, 35], [40, 35], [20, 50], [40, 50], [20, 65], [40, 65], [30, 42.5]]
            ];
            let color = val === 1 ? '#e74c3c' : (val % 2 === 0 ? '#27ae60' : '#2980b9');
            let r = val === 1 ? 14 : 7;
            positions[val].forEach(p => { svg += `<circle cx="${p[0]}" cy="${p[1]}" r="${r}" fill="${color}" stroke="#111" stroke-width="1"/>`; });
        } 
        else if (type === 'bam') {
            if (val === 1) {
                svg += `<circle cx="30" cy="45" r="16" fill="none" stroke="#27ae60" stroke-width="3"/>
                        <path d="M 30 25 L 35 45 L 50 45 L 38 55 L 42 70 L 30 60 L 18 70 L 22 55 L 10 45 L 25 45 Z" fill="#e74c3c"/>`;
            } else {
                const positions = [
                    [], [], [[30, 30], [30, 60]], [[30, 25], [20, 55], [40, 55]], 
                    [[20, 25], [40, 25], [20, 65], [40, 65]], [[20, 25], [40, 25], [30, 45], [20, 65], [40, 65]], 
                    [[20, 25], [40, 25], [20, 45], [40, 45], [20, 65], [40, 65]], 
                    [[20, 20], [40, 20], [30, 35], [20, 50], [40, 50], [20, 65], [40, 65]], 
                    [[20, 20], [40, 20], [20, 35], [40, 35], [20, 50], [40, 50], [20, 65], [40, 65]], 
                    [[20, 20], [30, 20], [40, 20], [20, 45], [30, 45], [40, 45], [20, 70], [30, 70], [40, 70]]
                ];
                positions[val].forEach(p => {
                    let color = (p[1] <= 25 || p[0] === 30 && val !== 9) ? '#2980b9' : '#27ae60';
                    if (val === 7 && p[1] < 40) color = '#e74c3c';
                    svg += `<rect x="${p[0]-3}" y="${p[1]-10}" width="6" height="20" rx="3" fill="${color}" stroke="#000" stroke-width="0.5"/>`;
                });
            }
        }
        else if (type === 'char') {
            const kanji = ["", "‰∏Ä", "‰∫å", "‰∏â", "Âõõ", "‰∫î", "ÂÖ≠", "‰∏É", "ÂÖ´", "‰πù"];
            svg += `<text x="30" y="35" font-size="22" font-family="sans-serif" font-weight="bold" text-anchor="middle" fill="#111">${kanji[val]}</text>
                    <text x="30" y="65" font-size="26" font-family="sans-serif" font-weight="bold" text-anchor="middle" fill="#e74c3c">Ëê¨</text>`;
        }
        else if (type === 'wind') {
            const map = { 'N': 'Âåó', 'S': 'Âçó', 'E': 'Êù±', 'W': 'Ë•ø' };
            svg += `<text x="30" y="55" font-size="36" font-family="sans-serif" font-weight="bold" text-anchor="middle" fill="#2c3e50">${map[val]}</text>`;
        }
        else if (type === 'dragon') {
            const map = { 'Red': '‰∏≠', 'Green': 'Áôº', 'White': 'ÁôΩ' };
            let color = val === 'Red' ? '#e74c3c' : (val === 'Green' ? '#27ae60' : '#2980b9');
            svg += `<text x="30" y="55" font-size="36" font-family="sans-serif" font-weight="bold" text-anchor="middle" fill="${color}">${map[val]}</text>`;
            if(val === 'White') svg += `<rect x="15" y="25" width="30" height="36" fill="none" stroke="#2980b9" stroke-width="4"/>`;
        }
        else if (type === 'flower') {
            svg += `<text x="30" y="55" font-size="36" text-anchor="middle">üå∏</text>`;
        }
        else if (type === 'season') {
            svg += `<text x="30" y="55" font-size="36" text-anchor="middle">‚ùÑÔ∏è</text>`;
        }

        svg += `</svg>`;
        return svg;
    }

    function isFree(tile) {
        const above = activeTiles.some(t => t.z === tile.z + 1 && t.x === tile.x && t.y === tile.y);
        if (above) return false;
        const blockedLeft = activeTiles.some(t => t.z === tile.z && t.y === tile.y && t.x === tile.x - 1);
        const blockedRight = activeTiles.some(t => t.z === tile.z && t.y === tile.y && t.x === tile.x + 1);
        return !(blockedLeft && blockedRight);
    }

    function updateVisibility() {
        activeTiles.forEach(t => {
            const el = document.getElementById(`tile-${t.id}`);
            if (!el) return;
            if (isFree(t)) {
                el.classList.remove('blocked');
            } else {
                el.classList.add('blocked');
                el.classList.remove('selected');
            }
        });
        
        if (selectedTileId !== null) {
            const t = activeTiles.find(x => x.id === selectedTileId);
            if(t && !isFree(t)) selectedTileId = null;
        }
    }

    function onTileClick(id) {
        const tile = activeTiles.find(t => t.id === id);
        if (!tile || !isFree(tile)) return; 

        if (selectedTileId === null) {
            selectedTileId = id;
            document.getElementById(`tile-${id}`).classList.add('selected');
        } else if (selectedTileId === id) {
            selectedTileId = null;
            document.getElementById(`tile-${id}`).classList.remove('selected');
        } else {
            const t1 = activeTiles.find(t => t.id === selectedTileId);
            const t2 = tile;

            if (isMatch(t1, t2)) {
                activeTiles = activeTiles.filter(t => t.id !== t1.id && t.id !== t2.id);
                document.getElementById(`tile-${t1.id}`).remove();
                document.getElementById(`tile-${t2.id}`).remove();
                selectedTileId = null;
                
                if (activeTiles.length === 0) {
                    document.getElementById('win-message').style.display = 'block';
                } else {
                    updateVisibility();
                }
            } else {
                document.getElementById(`tile-${selectedTileId}`).classList.remove('selected');
                selectedTileId = id;
                document.getElementById(`tile-${id}`).classList.add('selected');
            }
        }
    }

    function showHint() {
        document.querySelectorAll('.hint').forEach(el => el.classList.remove('hint'));
        const free = activeTiles.filter(isFree);
        for(let i=0; i<free.length; i++) {
            for(let j=i+1; j<free.length; j++) {
                if(isMatch(free[i], free[j])) {
                    const el1 = document.getElementById(`tile-${free[i].id}`);
                    const el2 = document.getElementById(`tile-${free[j].id}`);
                    if(el1 && el2) {
                        el1.classList.add('hint');
                        el2.classList.add('hint');
                        setTimeout(() => {
                            el1.classList.remove('hint');
                            el2.classList.remove('hint');
                        }, 3000);
                    }
                    return;
                }
            }
        }
        document.getElementById('hint-modal').style.display = 'flex';
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log(`Error attempting to enable full-screen mode: ${err.message}`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    function scaleBoard() {
        const container = document.getElementById('board-container');
        const wrapper = document.getElementById('board-scale-wrapper');
        const scaleX = (container.clientWidth - 20) / 1250; 
        const scaleY = (container.clientHeight - 20) / 750;
        const scale = Math.min(scaleX, scaleY, 1);
        wrapper.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }

    function assessDifficulty(board) {
        // 1. Count immediately free matching pairs
        let freeTiles = board.filter(isFree);
        let freePairs = 0;
        let checked = new Set();
        
        for (let i = 0; i < freeTiles.length; i++) {
            if (checked.has(freeTiles[i].id)) continue;
            for (let j = i + 1; j < freeTiles.length; j++) {
                if (!checked.has(freeTiles[j].id) && isMatch(freeTiles[i], freeTiles[j])) {
                    freePairs++;
                    checked.add(freeTiles[i].id);
                    checked.add(freeTiles[j].id);
                    break; 
                }
            }
        }

        // 2. Calculate average vertical depth
        let totalDepth = board.reduce((sum, tile) => sum + tile.z, 0);
        let avgDepth = totalDepth / board.length;

        // 3. Count "Hard Blocked" tiles (tiles that have another tile directly on top of them)
        let hardBlockedCount = board.filter(t => 
            board.some(above => above.z === t.z + 1 && above.x === t.x && above.y === t.y)
        ).length;

        // 4. Calculate final heuristic score
        // Higher free pairs = easier (lowers score)
        // Higher depth & hard blocks = harder (raises score)
        let difficultyScore = (avgDepth * 10) + (hardBlockedCount * 0.5) - (freePairs * 1.5);

        // 5. Categorize based on arbitrary thresholds (tweak these after testing)
        if (difficultyScore < 12) return "Easy";
        if (difficultyScore < 18) return "Medium";
        return "Hard";
    }

    function initGame(useInputSeed = false) {
        document.getElementById('win-message').style.display = 'none';
        const wrapper = document.getElementById('board-scale-wrapper');
        Array.from(wrapper.children).forEach(c => {
            if(c.id !== 'win-message') wrapper.removeChild(c);
        });

        const inputEl = document.getElementById('game-seed');
        if (useInputSeed && inputEl.value) {
            seed = parseInt(inputEl.value);
        } else {
            seed = Math.floor(Math.random() * 99999) + 1;
            inputEl.value = seed;
        }

        activeTiles = generateWinnableBoard();
        var difficultyScore = assessDifficulty(activeTiles);
        document.getElementById('difficulty-score').innerText = difficultyScore;
        selectedTileId = null;

        activeTiles.forEach(t => {
            const el = document.createElement('div');
            el.id = `tile-${t.id}`;
            el.className = 'tile';
            
            const baseX = t.x * 87;
            const baseY = t.y * 117;
            const zOffset = t.z * -8;
            
            el.style.left = `${baseX + zOffset + 15}px`; 
            el.style.top = `${baseY + zOffset + 15}px`;
            el.style.zIndex = (t.z * 100) + t.y + t.x;

            el.innerHTML = renderSVG(t.type, t.val);
            el.onclick = () => onTileClick(t.id);
            wrapper.appendChild(el);
        });

        updateVisibility();
        scaleBoard();
    }

    window.onload = () => {
        initGame(false);
        window.addEventListener('resize', scaleBoard);
        
        if (!document.documentElement.requestFullscreen) {
            document.getElementById('fullscreen-btn').style.display = 'none';
        }
    };
</script>
</body>
</html>